!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
Add	limonp/ThreadPool.hpp	/^  void Add(ClosureInterface* task) {$/;"	f	class:limonp::ThreadPool
ArgvContext	limonp/ArgvContext.hpp	/^  ArgvContext(int argc, const char* const * argv) {$/;"	f	class:limonp::ArgvContext
ArgvContext	limonp/ArgvContext.hpp	/^class ArgvContext {$/;"	c	namespace:limonp
B	HMMModel.hpp	/^  enum {B = 0, E = 1, M = 2, S = 3, STATUS_SUM = 4};$/;"	e	enum:cppjieba::HMMModel::__anon1
BLACK	limonp/Colors.hpp	/^  BLACK = 30,$/;"	e	enum:limonp::Color
BLUE	limonp/Colors.hpp	/^  BLUE,$/;"	e	enum:limonp::Color
BYTE	limonp/Md5.hpp	/^typedef unsigned char BYTE ;$/;"	t	namespace:limonp
BlockingQueue	limonp/BlockingQueue.hpp	/^  BlockingQueue()$/;"	f	class:limonp::BlockingQueue
BlockingQueue	limonp/BlockingQueue.hpp	/^class BlockingQueue: NonCopyable {$/;"	c	namespace:limonp
BoundedBlockingQueue	limonp/BoundedBlockingQueue.hpp	/^  explicit BoundedBlockingQueue(size_t maxSize)$/;"	f	class:limonp::BoundedBlockingQueue
BoundedBlockingQueue	limonp/BoundedBlockingQueue.hpp	/^class BoundedBlockingQueue : NonCopyable {$/;"	c	namespace:limonp
BoundedQueue	limonp/BoundedQueue.hpp	/^  explicit BoundedQueue(size_t capacity): capacity_(capacity), circular_buffer_(capacity) {$/;"	f	class:limonp::BoundedQueue
BoundedQueue	limonp/BoundedQueue.hpp	/^class BoundedQueue {$/;"	c	namespace:limonp
CPPJIBEA_HMMSEGMENT_H	HMMSegment.hpp	/^#define CPPJIBEA_HMMSEGMENT_H$/;"	d
CPPJIEAB_JIEBA_H	Jieba.hpp	/^#define CPPJIEAB_JIEBA_H$/;"	d
CPPJIEBA_DICT_TRIE_HPP	DictTrie.hpp	/^#define CPPJIEBA_DICT_TRIE_HPP$/;"	d
CPPJIEBA_FULLSEGMENT_H	FullSegment.hpp	/^#define CPPJIEBA_FULLSEGMENT_H$/;"	d
CPPJIEBA_HMMMODEL_H	HMMModel.hpp	/^#define CPPJIEBA_HMMMODEL_H$/;"	d
CPPJIEBA_KEYWORD_EXTRACTOR_H	KeywordExtractor.hpp	/^#define CPPJIEBA_KEYWORD_EXTRACTOR_H$/;"	d
CPPJIEBA_MIXSEGMENT_H	MixSegment.hpp	/^#define CPPJIEBA_MIXSEGMENT_H$/;"	d
CPPJIEBA_MPSEGMENT_H	MPSegment.hpp	/^#define CPPJIEBA_MPSEGMENT_H$/;"	d
CPPJIEBA_POS_TAGGING_H	PosTagger.hpp	/^#define CPPJIEBA_POS_TAGGING_H$/;"	d
CPPJIEBA_PRE_FILTER_H	PreFilter.hpp	/^#define CPPJIEBA_PRE_FILTER_H$/;"	d
CPPJIEBA_QUERYSEGMENT_H	QuerySegment.hpp	/^#define CPPJIEBA_QUERYSEGMENT_H$/;"	d
CPPJIEBA_SEGMENTBASE_H	SegmentBase.hpp	/^#define CPPJIEBA_SEGMENTBASE_H$/;"	d
CPPJIEBA_SEGMENTTAGGED_H	SegmentTagged.hpp	/^#define CPPJIEBA_SEGMENTTAGGED_H$/;"	d
CPPJIEBA_TEXTRANK_EXTRACTOR_H	TextRankExtractor.hpp	/^#define CPPJIEBA_TEXTRANK_EXTRACTOR_H$/;"	d
CPPJIEBA_TRIE_HPP	Trie.hpp	/^#define CPPJIEBA_TRIE_HPP$/;"	d
CPPJIEBA_UNICODE_H	Unicode.hpp	/^#define CPPJIEBA_UNICODE_H$/;"	d
CalcDP	MPSegment.hpp	/^  void CalcDP(vector<Dag>& dags) const {$/;"	f	class:cppjieba::MPSegment
CalcFreqSum	DictTrie.hpp	/^  double CalcFreqSum(const vector<DictUnit>& node_infos) const {$/;"	f	class:cppjieba::DictTrie
CalculateWeight	DictTrie.hpp	/^  void CalculateWeight(vector<DictUnit>& node_infos, double sum) const {$/;"	f	class:cppjieba::DictTrie
Capacity	limonp/BoundedQueue.hpp	/^  size_t Capacity() const {$/;"	f	class:limonp::BoundedQueue
Clear	limonp/BoundedQueue.hpp	/^  void Clear() {$/;"	f	class:limonp::BoundedQueue
Close	limonp/FileLock.hpp	/^  void Close() {$/;"	f	class:limonp::FileLock
Closure0	limonp/Closure.hpp	/^  Closure0(Funct fun) {$/;"	f	class:limonp::Closure0
Closure0	limonp/Closure.hpp	/^class Closure0: public ClosureInterface {$/;"	c	namespace:limonp
Closure1	limonp/Closure.hpp	/^  Closure1(Funct fun, Arg1 arg1) {$/;"	f	class:limonp::Closure1
Closure1	limonp/Closure.hpp	/^class Closure1: public ClosureInterface {$/;"	c	namespace:limonp
Closure2	limonp/Closure.hpp	/^  Closure2(Funct fun, Arg1 arg1, Arg2 arg2) {$/;"	f	class:limonp::Closure2
Closure2	limonp/Closure.hpp	/^class Closure2: public ClosureInterface {$/;"	c	namespace:limonp
Closure3	limonp/Closure.hpp	/^  Closure3(Funct fun, Arg1 arg1, Arg2 arg2, Arg3 arg3) {$/;"	f	class:limonp::Closure3
Closure3	limonp/Closure.hpp	/^class Closure3: public ClosureInterface {$/;"	c	namespace:limonp
ClosureInterface	limonp/Closure.hpp	/^class ClosureInterface {$/;"	c	namespace:limonp
Color	limonp/Colors.hpp	/^enum Color {$/;"	g	namespace:limonp
ColorPrintln	limonp/Colors.hpp	/^static void ColorPrintln(enum Color color, const char * fmt, ...) {$/;"	f	namespace:limonp
Compare	KeywordExtractor.hpp	/^  static bool Compare(const Word& lhs, const Word& rhs) {$/;"	f	class:cppjieba::KeywordExtractor
Compare	TextRankExtractor.hpp	/^    static bool Compare(const Word &x,const Word &y){$/;"	f	class:cppjieba::TextRankExtractor
Condition	limonp/Condition.hpp	/^  explicit Condition(MutexLock& mutex)$/;"	f	class:limonp::Condition
Condition	limonp/Condition.hpp	/^class Condition : NonCopyable {$/;"	c	namespace:limonp
Config	limonp/Config.hpp	/^  explicit Config(const string& filePath) {$/;"	f	class:limonp::Config
Config	limonp/Config.hpp	/^class Config {$/;"	c	namespace:limonp
CreateTrie	DictTrie.hpp	/^  void CreateTrie(const vector<DictUnit>& dictUnits) {$/;"	f	class:cppjieba::DictTrie
CreateTrie	Trie.hpp	/^  void CreateTrie(const vector<Unicode>& keys, const vector<const DictUnit*>& valuePointers) {$/;"	f	class:cppjieba::Trie
Cut	FullSegment.hpp	/^  void Cut(RuneStrArray::const_iterator begin, $/;"	f	class:cppjieba::FullSegment
Cut	FullSegment.hpp	/^  void Cut(const string& sentence, $/;"	f	class:cppjieba::FullSegment
Cut	HMMSegment.hpp	/^  void Cut(RuneStrArray::const_iterator begin, RuneStrArray::const_iterator end, vector<WordRange>& res) const {$/;"	f	class:cppjieba::HMMSegment
Cut	HMMSegment.hpp	/^  void Cut(const string& sentence, $/;"	f	class:cppjieba::HMMSegment
Cut	Jieba.hpp	/^  void Cut(const string& sentence, vector<Word>& words, bool hmm = true) const {$/;"	f	class:cppjieba::Jieba
Cut	Jieba.hpp	/^  void Cut(const string& sentence, vector<string>& words, bool hmm = true) const {$/;"	f	class:cppjieba::Jieba
Cut	MPSegment.hpp	/^  void Cut(RuneStrArray::const_iterator begin,$/;"	f	class:cppjieba::MPSegment
Cut	MPSegment.hpp	/^  void Cut(const string& sentence, $/;"	f	class:cppjieba::MPSegment
Cut	MPSegment.hpp	/^  void Cut(const string& sentence, vector<string>& words) const {$/;"	f	class:cppjieba::MPSegment
Cut	MPSegment.hpp	/^  void Cut(const string& sentence,$/;"	f	class:cppjieba::MPSegment
Cut	MixSegment.hpp	/^  void Cut(RuneStrArray::const_iterator begin, RuneStrArray::const_iterator end, vector<WordRange>& res, bool hmm) const {$/;"	f	class:cppjieba::MixSegment
Cut	MixSegment.hpp	/^  void Cut(const string& sentence, vector<Word>& words, bool hmm = true) const {$/;"	f	class:cppjieba::MixSegment
Cut	MixSegment.hpp	/^  void Cut(const string& sentence, vector<string>& words) const {$/;"	f	class:cppjieba::MixSegment
Cut	MixSegment.hpp	/^  void Cut(const string& sentence, vector<string>& words, bool hmm) const {$/;"	f	class:cppjieba::MixSegment
Cut	QuerySegment.hpp	/^  void Cut(RuneStrArray::const_iterator begin, RuneStrArray::const_iterator end, vector<WordRange>& res, bool hmm) const {$/;"	f	class:cppjieba::QuerySegment
Cut	QuerySegment.hpp	/^  void Cut(const string& sentence, vector<Word>& words, bool hmm = true) const {$/;"	f	class:cppjieba::QuerySegment
Cut	QuerySegment.hpp	/^  void Cut(const string& sentence, vector<string>& words) const {$/;"	f	class:cppjieba::QuerySegment
Cut	QuerySegment.hpp	/^  void Cut(const string& sentence, vector<string>& words, bool hmm) const {$/;"	f	class:cppjieba::QuerySegment
CutAll	Jieba.hpp	/^  void CutAll(const string& sentence, vector<Word>& words) const {$/;"	f	class:cppjieba::Jieba
CutAll	Jieba.hpp	/^  void CutAll(const string& sentence, vector<string>& words) const {$/;"	f	class:cppjieba::Jieba
CutByDag	MPSegment.hpp	/^  void CutByDag(RuneStrArray::const_iterator begin, $/;"	f	class:cppjieba::MPSegment
CutForSearch	Jieba.hpp	/^  void CutForSearch(const string& sentence, vector<Word>& words, bool hmm = true) const {$/;"	f	class:cppjieba::Jieba
CutForSearch	Jieba.hpp	/^  void CutForSearch(const string& sentence, vector<string>& words, bool hmm = true) const {$/;"	f	class:cppjieba::Jieba
CutHMM	Jieba.hpp	/^  void CutHMM(const string& sentence, vector<Word>& words) const {$/;"	f	class:cppjieba::Jieba
CutHMM	Jieba.hpp	/^  void CutHMM(const string& sentence, vector<string>& words) const {$/;"	f	class:cppjieba::Jieba
CutSmall	Jieba.hpp	/^  void CutSmall(const string& sentence, vector<Word>& words, size_t max_word_len) const {$/;"	f	class:cppjieba::Jieba
CutSmall	Jieba.hpp	/^  void CutSmall(const string& sentence, vector<string>& words, size_t max_word_len) const {$/;"	f	class:cppjieba::Jieba
DICT_COLUMN_NUM	DictTrie.hpp	/^const size_t DICT_COLUMN_NUM = 3;$/;"	m	namespace:cppjieba
Dag	Trie.hpp	/^  Dag():runestr(), pInfo(NULL), weight(0.0), nextPos(0) {$/;"	f	struct:cppjieba::Dag
Dag	Trie.hpp	/^struct Dag {$/;"	s	namespace:cppjieba
Decode	limonp/Md5.hpp	/^  static void Decode( UINT4 *output, unsigned char *input, unsigned int len ) {$/;"	f	class:limonp::MD5
DecodeRuneInString	Unicode.hpp	/^inline RuneStrLite DecodeRuneInString(const char* str, size_t len) {$/;"	f	namespace:cppjieba
DecodeRunesInString	Unicode.hpp	/^inline Unicode DecodeRunesInString(const string& s) {$/;"	f	namespace:cppjieba
DecodeRunesInString	Unicode.hpp	/^inline bool DecodeRunesInString(const char* s, size_t len, RuneStrArray& runes) {$/;"	f	namespace:cppjieba
DecodeRunesInString	Unicode.hpp	/^inline bool DecodeRunesInString(const char* s, size_t len, Unicode& unicode) {$/;"	f	namespace:cppjieba
DecodeRunesInString	Unicode.hpp	/^inline bool DecodeRunesInString(const string& s, RuneStrArray& runes) {$/;"	f	namespace:cppjieba
DecodeRunesInString	Unicode.hpp	/^inline bool DecodeRunesInString(const string& s, Unicode& unicode) {$/;"	f	namespace:cppjieba
DeleteNode	Trie.hpp	/^  void DeleteNode(TrieNode* node) {$/;"	f	class:cppjieba::Trie
DictTrie	DictTrie.hpp	/^  DictTrie(const string& dict_path, const string& user_dict_paths = "", UserWordWeightOption user_word_weight_opt = WordWeightMedian) {$/;"	f	class:cppjieba::DictTrie
DictTrie	DictTrie.hpp	/^class DictTrie {$/;"	c	namespace:cppjieba
DictUnit	Trie.hpp	/^struct DictUnit {$/;"	s	namespace:cppjieba
E	HMMModel.hpp	/^  enum {B = 0, E = 1, M = 2, S = 3, STATUS_SUM = 4};$/;"	e	enum:cppjieba::HMMModel::__anon1
Edges	TextRankExtractor.hpp	/^      typedef std::map<Node,double> Edges;$/;"	t	class:cppjieba::TextRankExtractor::WordGraph
EmitProbMap	HMMModel.hpp	/^typedef unordered_map<Rune, double> EmitProbMap;$/;"	t	namespace:cppjieba
Empty	limonp/BlockingQueue.hpp	/^  bool Empty() const {$/;"	f	class:limonp::BlockingQueue
Empty	limonp/BoundedBlockingQueue.hpp	/^  bool Empty() const {$/;"	f	class:limonp::BoundedBlockingQueue
Empty	limonp/BoundedQueue.hpp	/^  bool Empty() const {$/;"	f	class:limonp::BoundedQueue
Encode	limonp/Md5.hpp	/^  static void Encode( unsigned char *output, UINT4 *input, unsigned int len ) {$/;"	f	class:limonp::MD5
EndsWith	limonp/StringUtil.hpp	/^inline bool EndsWith(const string& str, const string& suffix) {$/;"	f	namespace:limonp
Error	limonp/FileLock.hpp	/^  string Error() const {$/;"	f	class:limonp::FileLock
Extract	KeywordExtractor.hpp	/^  void Extract(const string& sentence, vector<Word>& keywords, size_t topN) const {$/;"	f	class:cppjieba::KeywordExtractor
Extract	KeywordExtractor.hpp	/^  void Extract(const string& sentence, vector<pair<string, double> >& keywords, size_t topN) const {$/;"	f	class:cppjieba::KeywordExtractor
Extract	KeywordExtractor.hpp	/^  void Extract(const string& sentence, vector<string>& keywords, size_t topN) const {$/;"	f	class:cppjieba::KeywordExtractor
Extract	TextRankExtractor.hpp	/^    void Extract(const string& sentence, vector<Word>& keywords, size_t topN, size_t span=5,size_t rankTime=10) const {$/;"	f	class:cppjieba::TextRankExtractor
Extract	TextRankExtractor.hpp	/^    void Extract(const string& sentence, vector<pair<string, double> >& keywords, size_t topN) const {$/;"	f	class:cppjieba::TextRankExtractor
Extract	TextRankExtractor.hpp	/^    void Extract(const string& sentence, vector<string>& keywords, size_t topN) const {$/;"	f	class:cppjieba::TextRankExtractor
F	limonp/Md5.hpp	/^#define F(/;"	d
FF	limonp/Md5.hpp	/^#define FF(/;"	d
FileLock	limonp/FileLock.hpp	/^  FileLock() : fd_(-1), ok_(true) {$/;"	f	class:limonp::FileLock
FileLock	limonp/FileLock.hpp	/^class FileLock {$/;"	c	namespace:limonp
Final	limonp/Md5.hpp	/^  void Final() {$/;"	f	class:limonp::MD5
Find	DictTrie.hpp	/^  const DictUnit* Find(RuneStrArray::const_iterator begin, RuneStrArray::const_iterator end) const {$/;"	f	class:cppjieba::DictTrie
Find	DictTrie.hpp	/^  void Find(RuneStrArray::const_iterator begin, $/;"	f	class:cppjieba::DictTrie
Find	Trie.hpp	/^  const DictUnit* Find(RuneStrArray::const_iterator begin, RuneStrArray::const_iterator end) const {$/;"	f	class:cppjieba::Trie
Find	Trie.hpp	/^  void Find(RuneStrArray::const_iterator begin, $/;"	f	class:cppjieba::Trie
Full	limonp/BoundedBlockingQueue.hpp	/^  bool Full() const {$/;"	f	class:limonp::BoundedBlockingQueue
Full	limonp/BoundedQueue.hpp	/^  bool Full() const {$/;"	f	class:limonp::BoundedQueue
FullSegment	FullSegment.hpp	/^  FullSegment(const DictTrie* dictTrie)$/;"	f	class:cppjieba::FullSegment
FullSegment	FullSegment.hpp	/^  FullSegment(const string& dictPath) {$/;"	f	class:cppjieba::FullSegment
FullSegment	FullSegment.hpp	/^class FullSegment: public SegmentBase {$/;"	c	namespace:cppjieba
G	limonp/Md5.hpp	/^#define G(/;"	d
GBKTrans	limonp/StringUtil.hpp	/^bool GBKTrans(const char* const str, size_t len, Uint16Container& vec) {$/;"	f	namespace:limonp
GBKTrans	limonp/StringUtil.hpp	/^bool GBKTrans(const string& str, Uint16Container& vec) {$/;"	f	namespace:limonp
GBKTrans	limonp/StringUtil.hpp	/^void GBKTrans(Uint16ContainerConIter begin, Uint16ContainerConIter end, string& res) {$/;"	f	namespace:limonp
GG	limonp/Md5.hpp	/^#define GG(/;"	d
GREEN	limonp/Colors.hpp	/^  GREEN,$/;"	e	enum:limonp::Color
Get	limonp/Config.hpp	/^  int Get(const string& key, int defaultvalue) const {$/;"	f	class:limonp::Config
Get	limonp/Config.hpp	/^  string Get(const string& key, const string& defaultvalue) const {$/;"	f	class:limonp::Config
GetConfigInfo	limonp/Config.hpp	/^  string GetConfigInfo() const {$/;"	f	class:limonp::Config
GetDictTrie	Jieba.hpp	/^  const DictTrie* GetDictTrie() const {$/;"	f	class:cppjieba::Jieba
GetDictTrie	MPSegment.hpp	/^  const DictTrie* GetDictTrie() const {$/;"	f	class:cppjieba::MPSegment
GetDictTrie	MixSegment.hpp	/^  const DictTrie* GetDictTrie() const {$/;"	f	class:cppjieba::MixSegment
GetEmitProb	HMMModel.hpp	/^  double GetEmitProb(const EmitProbMap* ptMp, Rune key, $/;"	f	struct:cppjieba::HMMModel
GetHMMModel	Jieba.hpp	/^  const HMMModel* GetHMMModel() const {$/;"	f	class:cppjieba::Jieba
GetLine	HMMModel.hpp	/^  bool GetLine(ifstream& ifile, string& line) {$/;"	f	struct:cppjieba::HMMModel
GetMinWeight	DictTrie.hpp	/^  double GetMinWeight() const {$/;"	f	class:cppjieba::DictTrie
GetPthreadMutex	limonp/MutexLock.hpp	/^  pthread_mutex_t* GetPthreadMutex() {$/;"	f	class:limonp::MutexLock
GetStringFromRunes	Unicode.hpp	/^inline string GetStringFromRunes(const string& s, RuneStrArray::const_iterator left, RuneStrArray::const_iterator right) {$/;"	f	namespace:cppjieba
GetStringsFromWords	Unicode.hpp	/^inline void GetStringsFromWords(const vector<Word>& words, vector<string>& strs) {$/;"	f	namespace:cppjieba
GetTime	limonp/StringUtil.hpp	/^inline void GetTime(const string& format, string&  timeStr) {$/;"	f	namespace:limonp
GetWordFromRunes	Unicode.hpp	/^inline Word GetWordFromRunes(const string& s, RuneStrArray::const_iterator left, RuneStrArray::const_iterator right) {$/;"	f	namespace:cppjieba
GetWordsFromWordRanges	Unicode.hpp	/^inline vector<Word> GetWordsFromWordRanges(const string& s, const vector<WordRange>& wrs) {$/;"	f	namespace:cppjieba
GetWordsFromWordRanges	Unicode.hpp	/^inline void GetWordsFromWordRanges(const string& s, const vector<WordRange>& wrs, vector<Word>& words) {$/;"	f	namespace:cppjieba
Graph	TextRankExtractor.hpp	/^      typedef std::map<Node,Edges> Graph;$/;"	t	class:cppjieba::TextRankExtractor::WordGraph
H	limonp/Md5.hpp	/^#define H(/;"	d
HH	limonp/Md5.hpp	/^#define HH(/;"	d
HMMModel	HMMModel.hpp	/^  HMMModel(const string& modelPath) {$/;"	f	struct:cppjieba::HMMModel
HMMModel	HMMModel.hpp	/^struct HMMModel {$/;"	s	namespace:cppjieba
HMMSegment	HMMSegment.hpp	/^  HMMSegment(const HMMModel* model) $/;"	f	class:cppjieba::HMMSegment
HMMSegment	HMMSegment.hpp	/^  HMMSegment(const string& filePath)$/;"	f	class:cppjieba::HMMSegment
HMMSegment	HMMSegment.hpp	/^class HMMSegment: public SegmentBase {$/;"	c	namespace:cppjieba
HasKey	limonp/ArgvContext.hpp	/^  bool HasKey(const string& key) const {$/;"	f	class:limonp::ArgvContext
HasNext	PreFilter.hpp	/^  bool HasNext() const {$/;"	f	class:cppjieba::PreFilter
I	limonp/Md5.hpp	/^#define I(/;"	d
II	limonp/Md5.hpp	/^#define II(/;"	d
IThread	limonp/Thread.hpp	/^  IThread(): isStarted(false), isJoined(false) {$/;"	f	class:limonp::IThread
IThread	limonp/Thread.hpp	/^class IThread: NonCopyable {$/;"	c	namespace:limonp
Init	DictTrie.hpp	/^  void Init(const string& dict_path, const string& user_dict_paths, UserWordWeightOption user_word_weight_opt) {$/;"	f	class:cppjieba::DictTrie
Init	limonp/Md5.hpp	/^  void Init() {$/;"	f	class:limonp::MD5
InsertNode	Trie.hpp	/^  void InsertNode(const Unicode& key, const DictUnit* ptValue) {$/;"	f	class:cppjieba::Trie
InsertUserWord	DictTrie.hpp	/^  bool InsertUserWord(const string& word, const string& tag = UNKNOWN_TAG) {$/;"	f	class:cppjieba::DictTrie
InsertUserWord	Jieba.hpp	/^  bool InsertUserWord(const string& word, const string& tag = UNKNOWN_TAG) {$/;"	f	class:cppjieba::Jieba
InternalCut	HMMSegment.hpp	/^  void InternalCut(RuneStrArray::const_iterator begin, RuneStrArray::const_iterator end, vector<WordRange>& res) const {$/;"	f	class:cppjieba::HMMSegment
IsAllAscii	QuerySegment.hpp	/^  bool IsAllAscii(const Unicode& s) const {$/;"	f	class:cppjieba::QuerySegment
IsAllAscii	Unicode.hpp	/^  bool IsAllAscii() const {$/;"	f	struct:cppjieba::WordRange
IsIn	limonp/StdExtension.hpp	/^bool IsIn(const ContainType& contain, const KeyType& key) {$/;"	f	namespace:std
IsInStr	limonp/StringUtil.hpp	/^inline bool IsInStr(const string& str, char ch) {$/;"	f	namespace:limonp
IsSingleWord	Unicode.hpp	/^inline bool IsSingleWord(const string& str) {$/;"	f	namespace:cppjieba
IsSpace	limonp/StringUtil.hpp	/^inline bool IsSpace(unsigned c) {$/;"	f	namespace:limonp
IsUserDictSingleChineseWord	DictTrie.hpp	/^  bool IsUserDictSingleChineseWord(const Rune& word) const {$/;"	f	class:cppjieba::DictTrie
IsUserDictSingleChineseWord	MPSegment.hpp	/^  bool IsUserDictSingleChineseWord(const Rune& value) const {$/;"	f	class:cppjieba::MPSegment
Jieba	Jieba.hpp	/^  Jieba(const string& dict_path, const string& model_path, const string& user_dict_path) $/;"	f	class:cppjieba::Jieba
Jieba	Jieba.hpp	/^class Jieba {$/;"	c	namespace:cppjieba
Join	limonp/StringUtil.hpp	/^string Join(T begin, T end, const string& connector) {$/;"	f	namespace:limonp
Join	limonp/StringUtil.hpp	/^void Join(T begin, T end, string& res, const string& connector) {$/;"	f	namespace:limonp
Join	limonp/Thread.hpp	/^  void Join() {$/;"	f	class:limonp::IThread
KeywordExtractor	KeywordExtractor.hpp	/^  KeywordExtractor(const DictTrie* dictTrie, $/;"	f	class:cppjieba::KeywordExtractor
KeywordExtractor	KeywordExtractor.hpp	/^  KeywordExtractor(const Jieba& jieba, $/;"	f	class:cppjieba::KeywordExtractor
KeywordExtractor	KeywordExtractor.hpp	/^  KeywordExtractor(const string& dictPath, $/;"	f	class:cppjieba::KeywordExtractor
KeywordExtractor	KeywordExtractor.hpp	/^class KeywordExtractor {$/;"	c	namespace:cppjieba
LIMONP_ARGV_FUNCTS_H	limonp/ArgvContext.hpp	/^#define LIMONP_ARGV_FUNCTS_H$/;"	d
LIMONP_BLOCKINGQUEUE_HPP	limonp/BlockingQueue.hpp	/^#define LIMONP_BLOCKINGQUEUE_HPP$/;"	d
LIMONP_BOUNDED_BLOCKING_QUEUE_HPP	limonp/BoundedBlockingQueue.hpp	/^#define LIMONP_BOUNDED_BLOCKING_QUEUE_HPP$/;"	d
LIMONP_BOUNDED_QUEUE_HPP	limonp/BoundedQueue.hpp	/^#define LIMONP_BOUNDED_QUEUE_HPP$/;"	d
LIMONP_CLOSURE_HPP	limonp/Closure.hpp	/^#define LIMONP_CLOSURE_HPP$/;"	d
LIMONP_COLOR_PRINT_HPP	limonp/Colors.hpp	/^#define LIMONP_COLOR_PRINT_HPP$/;"	d
LIMONP_CONDITION_HPP	limonp/Condition.hpp	/^#define LIMONP_CONDITION_HPP$/;"	d
LIMONP_CONFIG_H	limonp/Config.hpp	/^#define LIMONP_CONFIG_H$/;"	d
LIMONP_FILELOCK_HPP	limonp/FileLock.hpp	/^#define LIMONP_FILELOCK_HPP$/;"	d
LIMONP_FORCE_PUBLIC_H	limonp/ForcePublic.hpp	/^#define LIMONP_FORCE_PUBLIC_H$/;"	d
LIMONP_LOCAL_VECTOR_HPP	limonp/LocalVector.hpp	/^#define LIMONP_LOCAL_VECTOR_HPP$/;"	d
LIMONP_LOGGING_HPP	limonp/Logging.hpp	/^#define LIMONP_LOGGING_HPP$/;"	d
LIMONP_MUTEX_LOCK_HPP	limonp/MutexLock.hpp	/^#define LIMONP_MUTEX_LOCK_HPP$/;"	d
LIMONP_NONCOPYABLE_H	limonp/NonCopyable.hpp	/^#define LIMONP_NONCOPYABLE_H$/;"	d
LIMONP_STD_EXTEMSION_HPP	limonp/StdExtension.hpp	/^#define LIMONP_STD_EXTEMSION_HPP$/;"	d
LIMONP_STR_FUNCTS_H	limonp/StringUtil.hpp	/^#define LIMONP_STR_FUNCTS_H$/;"	d
LIMONP_THREAD_HPP	limonp/Thread.hpp	/^#define LIMONP_THREAD_HPP$/;"	d
LIMONP_THREAD_POOL_HPP	limonp/ThreadPool.hpp	/^#define LIMONP_THREAD_POOL_HPP$/;"	d
LL_DEBUG	limonp/Logging.hpp	/^  LL_DEBUG = 0, $/;"	e	enum:limonp::__anon2
LL_ERROR	limonp/Logging.hpp	/^  LL_ERROR = 3, $/;"	e	enum:limonp::__anon2
LL_FATAL	limonp/Logging.hpp	/^  LL_FATAL = 4,$/;"	e	enum:limonp::__anon2
LL_INFO	limonp/Logging.hpp	/^  LL_INFO = 1, $/;"	e	enum:limonp::__anon2
LL_WARNING	limonp/Logging.hpp	/^  LL_WARNING = 2, $/;"	e	enum:limonp::__anon2
LOCAL_VECTOR_BUFFER_SIZE	limonp/LocalVector.hpp	/^const size_t LOCAL_VECTOR_BUFFER_SIZE = 16;$/;"	m	namespace:limonp
LOG_LEVEL_ARRAY	limonp/Logging.hpp	/^static const char * LOG_LEVEL_ARRAY[] = {"DEBUG","INFO","WARN","ERROR","FATAL"};$/;"	m	namespace:limonp
LOG_TIME_FORMAT	limonp/Logging.hpp	/^static const char * LOG_TIME_FORMAT = "%Y-%m-%d %H:%M:%S";$/;"	m	namespace:limonp
LTrim	limonp/StringUtil.hpp	/^inline std::string& LTrim(std::string & s, char x) {$/;"	f	namespace:limonp
LTrim	limonp/StringUtil.hpp	/^inline std::string& LTrim(std::string &s) {$/;"	f	namespace:limonp
Length	Unicode.hpp	/^  size_t Length() const {$/;"	f	struct:cppjieba::WordRange
LoadDict	DictTrie.hpp	/^  void LoadDict(const string& filePath) {$/;"	f	class:cppjieba::DictTrie
LoadEmitProb	HMMModel.hpp	/^  bool LoadEmitProb(const string& line, EmitProbMap& mp) {$/;"	f	struct:cppjieba::HMMModel
LoadFile	limonp/Config.hpp	/^  void LoadFile(const string& filePath) {$/;"	f	class:limonp::Config
LoadIdfDict	KeywordExtractor.hpp	/^  void LoadIdfDict(const string& idfPath) {$/;"	f	class:cppjieba::KeywordExtractor
LoadModel	HMMModel.hpp	/^  void LoadModel(const string& filePath) {$/;"	f	struct:cppjieba::HMMModel
LoadStopWordDict	KeywordExtractor.hpp	/^  void LoadStopWordDict(const string& filePath) {$/;"	f	class:cppjieba::KeywordExtractor
LoadStopWordDict	TextRankExtractor.hpp	/^    void LoadStopWordDict(const string& filePath) {$/;"	f	class:cppjieba::TextRankExtractor
LoadUserDict	DictTrie.hpp	/^  void LoadUserDict(const string& filePaths) {$/;"	f	class:cppjieba::DictTrie
LocWord	Jieba.hpp	/^  struct LocWord {$/;"	s	class:cppjieba::Jieba
LocalVector	limonp/LocalVector.hpp	/^  LocalVector() {$/;"	f	class:limonp::LocalVector
LocalVector	limonp/LocalVector.hpp	/^  LocalVector(const LocalVector<T>& vec) {$/;"	f	class:limonp::LocalVector
LocalVector	limonp/LocalVector.hpp	/^  LocalVector(const_iterator  begin, const_iterator end) { \/\/ TODO: make it faster$/;"	f	class:limonp::LocalVector
LocalVector	limonp/LocalVector.hpp	/^  LocalVector(size_t size, const T& t) { \/\/ TODO: make it faster$/;"	f	class:limonp::LocalVector
LocalVector	limonp/LocalVector.hpp	/^class LocalVector {$/;"	c	namespace:limonp
Lock	limonp/FileLock.hpp	/^  void Lock() {$/;"	f	class:limonp::FileLock
Lock	limonp/MutexLock.hpp	/^  void Lock() {$/;"	f	class:limonp::MutexLock
LockOrUnlock	limonp/FileLock.hpp	/^  static int LockOrUnlock(int fd, bool lock) {$/;"	f	class:limonp::FileLock
Logger	limonp/Logging.hpp	/^  Logger(size_t level, const char* filename, int lineno)$/;"	f	class:limonp::Logger
Logger	limonp/Logging.hpp	/^class Logger {$/;"	c	namespace:limonp
LookupTag	Jieba.hpp	/^  string LookupTag(const string &str) const {$/;"	f	class:cppjieba::Jieba
LookupTag	MixSegment.hpp	/^  string LookupTag(const string &str) const {$/;"	f	class:cppjieba::MixSegment
LookupTag	PosTagger.hpp	/^  string LookupTag(const string &str, const SegmentTagged& segment) const {$/;"	f	class:cppjieba::PosTagger
Lower	limonp/StringUtil.hpp	/^inline string& Lower(string& str) {$/;"	f	namespace:limonp
M	HMMModel.hpp	/^  enum {B = 0, E = 1, M = 2, S = 3, STATUS_SUM = 4};$/;"	e	enum:cppjieba::HMMModel::__anon1
MAX_DOUBLE	DictTrie.hpp	/^const double MAX_DOUBLE = 3.14e+100;$/;"	m	namespace:cppjieba
MAX_WORD_LENGTH	Trie.hpp	/^const size_t MAX_WORD_LENGTH = 512;$/;"	m	namespace:cppjieba
MD5	limonp/Md5.hpp	/^  MD5() {$/;"	f	class:limonp::MD5
MD5	limonp/Md5.hpp	/^class MD5 {$/;"	c	namespace:limonp
MD5Transform	limonp/Md5.hpp	/^  static void MD5Transform( UINT4 state[4], unsigned char block[64] ) {$/;"	f	class:limonp::MD5
MIN_DOUBLE	DictTrie.hpp	/^const double MIN_DOUBLE = -3.14e+100;$/;"	m	namespace:cppjieba
MPSegment	MPSegment.hpp	/^  MPSegment(const DictTrie* dictTrie)$/;"	f	class:cppjieba::MPSegment
MPSegment	MPSegment.hpp	/^  MPSegment(const string& dictPath, const string& userDictPath = "")$/;"	f	class:cppjieba::MPSegment
MPSegment	MPSegment.hpp	/^class MPSegment: public SegmentTagged {$/;"	c	namespace:cppjieba
MakeNodeInfo	DictTrie.hpp	/^  bool MakeNodeInfo(DictUnit& node_info,$/;"	f	class:cppjieba::DictTrie
MixSegment	MixSegment.hpp	/^  MixSegment(const DictTrie* dictTrie, const HMMModel* model) $/;"	f	class:cppjieba::MixSegment
MixSegment	MixSegment.hpp	/^  MixSegment(const string& mpSegDict, const string& hmmSegDict, $/;"	f	class:cppjieba::MixSegment
MixSegment	MixSegment.hpp	/^class MixSegment: public SegmentTagged {$/;"	c	namespace:cppjieba
MutexLock	limonp/MutexLock.hpp	/^  MutexLock() {$/;"	f	class:limonp::MutexLock
MutexLock	limonp/MutexLock.hpp	/^class MutexLock: NonCopyable {$/;"	c	namespace:limonp
MutexLockGuard	limonp/MutexLock.hpp	/^  explicit MutexLockGuard(MutexLock & mutex)$/;"	f	class:limonp::MutexLockGuard
MutexLockGuard	limonp/MutexLock.hpp	/^#define MutexLockGuard(/;"	d
MutexLockGuard	limonp/MutexLock.hpp	/^class MutexLockGuard: NonCopyable {$/;"	c	namespace:limonp
NewClosure	limonp/Closure.hpp	/^ClosureInterface* NewClosure(Obj* obj, R (Obj::* fun)()) {$/;"	f	namespace:limonp
NewClosure	limonp/Closure.hpp	/^ClosureInterface* NewClosure(Obj* obj, R (Obj::* fun)(Arg1), Arg1 arg1) {$/;"	f	namespace:limonp
NewClosure	limonp/Closure.hpp	/^ClosureInterface* NewClosure(Obj* obj, R (Obj::* fun)(Arg1, Arg2), Arg1 arg1, Arg2 arg2) {$/;"	f	namespace:limonp
NewClosure	limonp/Closure.hpp	/^ClosureInterface* NewClosure(Obj* obj, R (Obj::* fun)(Arg1, Arg2, Arg3), Arg1 arg1, Arg2 arg2, Arg3 arg3) {$/;"	f	namespace:limonp
NewClosure	limonp/Closure.hpp	/^ClosureInterface* NewClosure(R (*fun)()) {$/;"	f	namespace:limonp
NewClosure	limonp/Closure.hpp	/^ClosureInterface* NewClosure(R (*fun)(Arg1), Arg1 arg1) {$/;"	f	namespace:limonp
NewClosure	limonp/Closure.hpp	/^ClosureInterface* NewClosure(R (*fun)(Arg1, Arg2), Arg1 arg1, Arg2 arg2) {$/;"	f	namespace:limonp
NewClosure	limonp/Closure.hpp	/^ClosureInterface* NewClosure(R (*fun)(Arg1, Arg2, Arg3), Arg1 arg1, Arg2 arg2, Arg3 arg3) {$/;"	f	namespace:limonp
Next	PreFilter.hpp	/^  Range Next() {$/;"	f	class:cppjieba::PreFilter
NextMap	Trie.hpp	/^  typedef unordered_map<TrieKey, TrieNode*> NextMap;$/;"	t	class:cppjieba::TrieNode
Node	TextRankExtractor.hpp	/^      typedef string Node;$/;"	t	class:cppjieba::TextRankExtractor::WordGraph
NodeSet	TextRankExtractor.hpp	/^      typedef std::set<Node> NodeSet;$/;"	t	class:cppjieba::TextRankExtractor::WordGraph
NonCopyable	limonp/NonCopyable.hpp	/^  NonCopyable() {$/;"	f	class:limonp::NonCopyable
NonCopyable	limonp/NonCopyable.hpp	/^class NonCopyable {$/;"	c	namespace:limonp
Notify	limonp/Condition.hpp	/^  void Notify() {$/;"	f	class:limonp::Condition
NotifyAll	limonp/Condition.hpp	/^  void NotifyAll() {$/;"	f	class:limonp::Condition
NumbersRule	HMMSegment.hpp	/^  RuneStrArray::const_iterator NumbersRule(RuneStrArray::const_iterator begin, RuneStrArray::const_iterator end) const {$/;"	f	class:cppjieba::HMMSegment
ObjClosure0	limonp/Closure.hpp	/^  ObjClosure0(Obj* p, Funct fun) {$/;"	f	class:limonp::ObjClosure0
ObjClosure0	limonp/Closure.hpp	/^class ObjClosure0: public ClosureInterface {$/;"	c	namespace:limonp
ObjClosure1	limonp/Closure.hpp	/^  ObjClosure1(Obj* p, Funct fun, Arg1 arg1) {$/;"	f	class:limonp::ObjClosure1
ObjClosure1	limonp/Closure.hpp	/^class ObjClosure1: public ClosureInterface {$/;"	c	namespace:limonp
ObjClosure2	limonp/Closure.hpp	/^  ObjClosure2(Obj* p, Funct fun, Arg1 arg1, Arg2 arg2) {$/;"	f	class:limonp::ObjClosure2
ObjClosure2	limonp/Closure.hpp	/^class ObjClosure2: public ClosureInterface {$/;"	c	namespace:limonp
ObjClosure3	limonp/Closure.hpp	/^  ObjClosure3(Obj* p, Funct fun, Arg1 arg1, Arg2 arg2, Arg3 arg3) {$/;"	f	class:limonp::ObjClosure3
ObjClosure3	limonp/Closure.hpp	/^class ObjClosure3: public ClosureInterface {$/;"	c	namespace:limonp
Ok	limonp/FileLock.hpp	/^  bool Ok() const {$/;"	f	class:limonp::FileLock
Open	limonp/FileLock.hpp	/^  void Open(const string& fname) {$/;"	f	class:limonp::FileLock
PADDING	limonp/Md5.hpp	/^static unsigned char PADDING[64] = {$/;"	m	namespace:limonp
POINTER	limonp/Md5.hpp	/^typedef unsigned char *POINTER;$/;"	t	namespace:limonp
POS_ENG	PosTagger.hpp	/^static const char* const POS_ENG = "eng";$/;"	m	namespace:cppjieba
POS_M	PosTagger.hpp	/^static const char* const POS_M = "m";$/;"	m	namespace:cppjieba
POS_X	PosTagger.hpp	/^static const char* const POS_X = "x";$/;"	m	namespace:cppjieba
PURPLE	limonp/Colors.hpp	/^  PURPLE$/;"	e	enum:limonp::Color
PathJoin	limonp/StringUtil.hpp	/^inline string PathJoin(const string& path1, const string& path2) {$/;"	f	namespace:limonp
Pop	limonp/BlockingQueue.hpp	/^  T Pop() {$/;"	f	class:limonp::BlockingQueue
Pop	limonp/BoundedBlockingQueue.hpp	/^  T Pop() {$/;"	f	class:limonp::BoundedBlockingQueue
Pop	limonp/BoundedQueue.hpp	/^  T Pop() {$/;"	f	class:limonp::BoundedQueue
PosTagger	PosTagger.hpp	/^  PosTagger() {$/;"	f	class:cppjieba::PosTagger
PosTagger	PosTagger.hpp	/^class PosTagger {$/;"	c	namespace:cppjieba
PreFilter	PreFilter.hpp	/^  PreFilter(const unordered_set<Rune>& symbols, $/;"	f	class:cppjieba::PreFilter
PreFilter	PreFilter.hpp	/^class PreFilter {$/;"	c	namespace:cppjieba
Push	limonp/BlockingQueue.hpp	/^  void Push(const T& x) {$/;"	f	class:limonp::BlockingQueue
Push	limonp/BoundedBlockingQueue.hpp	/^  void Push(const T& x) {$/;"	f	class:limonp::BoundedBlockingQueue
Push	limonp/BoundedQueue.hpp	/^  void Push(const T& t) {$/;"	f	class:limonp::BoundedQueue
QuerySegment	QuerySegment.hpp	/^  QuerySegment(const DictTrie* dictTrie, const HMMModel* model)$/;"	f	class:cppjieba::QuerySegment
QuerySegment	QuerySegment.hpp	/^  QuerySegment(const string& dict, const string& model, const string& userDict = "")$/;"	f	class:cppjieba::QuerySegment
QuerySegment	QuerySegment.hpp	/^class QuerySegment: public SegmentBase {$/;"	c	namespace:cppjieba
RED	limonp/Colors.hpp	/^  RED,$/;"	e	enum:limonp::Color
ROTATE_LEFT	limonp/Md5.hpp	/^#define ROTATE_LEFT(/;"	d
RTrim	limonp/StringUtil.hpp	/^inline std::string& RTrim(std::string & s, char x) {$/;"	f	namespace:limonp
RTrim	limonp/StringUtil.hpp	/^inline std::string& RTrim(std::string &s) {$/;"	f	namespace:limonp
Range	PreFilter.hpp	/^  struct Range {$/;"	s	class:cppjieba::PreFilter
ResetSeparators	Jieba.hpp	/^  void ResetSeparators(const string& s) {$/;"	f	class:cppjieba::Jieba
ResetSeparators	SegmentBase.hpp	/^  bool ResetSeparators(const string& s) {$/;"	f	class:cppjieba::SegmentBase
Run	limonp/Closure.hpp	/^  virtual void Run() {$/;"	f	class:limonp::Closure0
Run	limonp/Closure.hpp	/^  virtual void Run() {$/;"	f	class:limonp::Closure1
Run	limonp/Closure.hpp	/^  virtual void Run() {$/;"	f	class:limonp::Closure2
Run	limonp/Closure.hpp	/^  virtual void Run() {$/;"	f	class:limonp::Closure3
Run	limonp/Closure.hpp	/^  virtual void Run() {$/;"	f	class:limonp::ObjClosure0
Run	limonp/Closure.hpp	/^  virtual void Run() {$/;"	f	class:limonp::ObjClosure1
Run	limonp/Closure.hpp	/^  virtual void Run() {$/;"	f	class:limonp::ObjClosure2
Run	limonp/Closure.hpp	/^  virtual void Run() {$/;"	f	class:limonp::ObjClosure3
Run	limonp/ThreadPool.hpp	/^    virtual void Run() {$/;"	f	class:limonp::ThreadPool::Worker
Rune	Unicode.hpp	/^typedef uint32_t Rune;$/;"	t	namespace:cppjieba
RuneStr	Unicode.hpp	/^  RuneStr(): rune(0), offset(0), len(0) {$/;"	f	struct:cppjieba::RuneStr
RuneStr	Unicode.hpp	/^  RuneStr(Rune r, uint32_t o, uint32_t l)$/;"	f	struct:cppjieba::RuneStr
RuneStr	Unicode.hpp	/^struct RuneStr {$/;"	s	namespace:cppjieba
RuneStrArray	Unicode.hpp	/^typedef limonp::LocalVector<struct RuneStr> RuneStrArray;$/;"	t	namespace:cppjieba
RuneStrLite	Unicode.hpp	/^  RuneStrLite(): rune(0), len(0) {$/;"	f	struct:cppjieba::RuneStrLite
RuneStrLite	Unicode.hpp	/^  RuneStrLite(uint32_t r, uint32_t l): rune(r), len(l) {$/;"	f	struct:cppjieba::RuneStrLite
RuneStrLite	Unicode.hpp	/^struct RuneStrLite {$/;"	s	namespace:cppjieba
S	HMMModel.hpp	/^  enum {B = 0, E = 1, M = 2, S = 3, STATUS_SUM = 4};$/;"	e	enum:cppjieba::HMMModel::__anon1
S11	limonp/Md5.hpp	/^#define S11 /;"	d
S12	limonp/Md5.hpp	/^#define S12 /;"	d
S13	limonp/Md5.hpp	/^#define S13 /;"	d
S14	limonp/Md5.hpp	/^#define S14 /;"	d
S21	limonp/Md5.hpp	/^#define S21 /;"	d
S22	limonp/Md5.hpp	/^#define S22 /;"	d
S23	limonp/Md5.hpp	/^#define S23 /;"	d
S24	limonp/Md5.hpp	/^#define S24 /;"	d
S31	limonp/Md5.hpp	/^#define S31 /;"	d
S32	limonp/Md5.hpp	/^#define S32 /;"	d
S33	limonp/Md5.hpp	/^#define S33 /;"	d
S34	limonp/Md5.hpp	/^#define S34 /;"	d
S41	limonp/Md5.hpp	/^#define S41 /;"	d
S42	limonp/Md5.hpp	/^#define S42 /;"	d
S43	limonp/Md5.hpp	/^#define S43 /;"	d
S44	limonp/Md5.hpp	/^#define S44 /;"	d
SPECIAL_SEPARATORS	SegmentBase.hpp	/^const char* const SPECIAL_SEPARATORS = " \\t\\n\\xEF\\xBC\\x8C\\xE3\\x80\\x82";$/;"	m	namespace:cppjieba
STATUS_SUM	HMMModel.hpp	/^  enum {B = 0, E = 1, M = 2, S = 3, STATUS_SUM = 4};$/;"	e	enum:cppjieba::HMMModel::__anon1
Score	TextRankExtractor.hpp	/^      typedef double Score;$/;"	t	class:cppjieba::TextRankExtractor::WordGraph
SegmentBase	SegmentBase.hpp	/^  SegmentBase() {$/;"	f	class:cppjieba::SegmentBase
SegmentBase	SegmentBase.hpp	/^class SegmentBase {$/;"	c	namespace:cppjieba
SegmentTagged	SegmentTagged.hpp	/^  SegmentTagged() {$/;"	f	class:cppjieba::SegmentTagged
SegmentTagged	SegmentTagged.hpp	/^class SegmentTagged : public SegmentBase{$/;"	c	namespace:cppjieba
SequentialLetterRule	HMMSegment.hpp	/^  RuneStrArray::const_iterator SequentialLetterRule(RuneStrArray::const_iterator begin, RuneStrArray::const_iterator end) const {$/;"	f	class:cppjieba::HMMSegment
SetStaticWordWeights	DictTrie.hpp	/^  void SetStaticWordWeights(UserWordWeightOption option) {$/;"	f	class:cppjieba::DictTrie
Shrink	DictTrie.hpp	/^  void Shrink(vector<DictUnit>& units) const {$/;"	f	class:cppjieba::DictTrie
Size	limonp/BlockingQueue.hpp	/^  size_t Size() const {$/;"	f	class:limonp::BlockingQueue
Size	limonp/BoundedQueue.hpp	/^  size_t Size() const {$/;"	f	class:limonp::BoundedQueue
SpecialRule	PosTagger.hpp	/^  const char* SpecialRule(const RuneStrArray& unicode) const {$/;"	f	class:cppjieba::PosTagger
Split	limonp/StringUtil.hpp	/^inline vector<string> Split(const string& src, const string& pattern, size_t maxsplit = string::npos) {$/;"	f	namespace:limonp
Split	limonp/StringUtil.hpp	/^inline void Split(const string& src, vector<string>& res, const string& pattern, size_t maxsplit = string::npos) {$/;"	f	namespace:limonp
Start	limonp/Thread.hpp	/^  void Start() {$/;"	f	class:limonp::IThread
Start	limonp/ThreadPool.hpp	/^  void Start() {$/;"	f	class:limonp::ThreadPool
StartsWith	limonp/StringUtil.hpp	/^inline bool StartsWith(const string& str, const string& prefix) {$/;"	f	namespace:limonp
Stop	limonp/ThreadPool.hpp	/^  void Stop() {$/;"	f	class:limonp::ThreadPool
Stream	limonp/Logging.hpp	/^  std::ostream& Stream() {$/;"	f	class:limonp::Logger
StringFormat	limonp/StringUtil.hpp	/^inline string StringFormat(const char* fmt, ...) {$/;"	f	namespace:limonp
Tag	Jieba.hpp	/^  void Tag(const string& sentence, vector<pair<string, string> >& words) const {$/;"	f	class:cppjieba::Jieba
Tag	MPSegment.hpp	/^  bool Tag(const string& src, vector<pair<string, string> >& res) const {$/;"	f	class:cppjieba::MPSegment
Tag	MixSegment.hpp	/^  bool Tag(const string& src, vector<pair<string, string> >& res) const {$/;"	f	class:cppjieba::MixSegment
Tag	PosTagger.hpp	/^  bool Tag(const string& src, vector<pair<string, string> >& res, const SegmentTagged& segment) const {$/;"	f	class:cppjieba::PosTagger
TextRankExtractor	TextRankExtractor.hpp	/^    TextRankExtractor(const Jieba& jieba, const string& stopWordPath) : segment_(jieba.GetDictTrie(), jieba.GetHMMModel()) {$/;"	f	class:cppjieba::TextRankExtractor
TextRankExtractor	TextRankExtractor.hpp	/^  TextRankExtractor(const DictTrie* dictTrie, $/;"	f	class:cppjieba::TextRankExtractor
TextRankExtractor	TextRankExtractor.hpp	/^  TextRankExtractor(const string& dictPath, $/;"	f	class:cppjieba::TextRankExtractor
TextRankExtractor	TextRankExtractor.hpp	/^  class TextRankExtractor {$/;"	c	namespace:cppjieba
ThreadPool	limonp/ThreadPool.hpp	/^  ThreadPool(size_t thread_num)$/;"	f	class:limonp::ThreadPool
ThreadPool	limonp/ThreadPool.hpp	/^class ThreadPool: NonCopyable {$/;"	c	namespace:limonp
Trie	Trie.hpp	/^  Trie(const vector<Unicode>& keys, const vector<const DictUnit*>& valuePointers)$/;"	f	class:cppjieba::Trie
Trie	Trie.hpp	/^class Trie {$/;"	c	namespace:cppjieba
TrieKey	Trie.hpp	/^typedef Rune TrieKey;$/;"	t	namespace:cppjieba
TrieNode	Trie.hpp	/^  TrieNode(): next(NULL), ptValue(NULL) {$/;"	f	class:cppjieba::TrieNode
TrieNode	Trie.hpp	/^class TrieNode {$/;"	c	namespace:cppjieba
Trim	limonp/StringUtil.hpp	/^inline std::string& Trim(std::string &s) {$/;"	f	namespace:limonp
Trim	limonp/StringUtil.hpp	/^inline std::string& Trim(std::string &s, char x) {$/;"	f	namespace:limonp
TwocharToUint16	limonp/StringUtil.hpp	/^inline uint16_t TwocharToUint16(char high, char low) {$/;"	f	namespace:limonp
UINT2	limonp/Md5.hpp	/^typedef unsigned short int UINT2;$/;"	t	namespace:limonp
UINT4	limonp/Md5.hpp	/^typedef unsigned int UINT4;$/;"	t	namespace:limonp
UNKNOWN_TAG	DictTrie.hpp	/^const char* const UNKNOWN_TAG = "";$/;"	m	namespace:cppjieba
UnLock	limonp/FileLock.hpp	/^  void UnLock() {$/;"	f	class:limonp::FileLock
Unicode	Unicode.hpp	/^typedef limonp::LocalVector<Rune> Unicode;$/;"	t	namespace:cppjieba
Unicode32ToUtf8	limonp/StringUtil.hpp	/^void Unicode32ToUtf8(Uint32ContainerConIter begin, Uint32ContainerConIter end, string& res) {$/;"	f	namespace:limonp
UnicodeToUtf8	limonp/StringUtil.hpp	/^void UnicodeToUtf8(Uint16ContainerConIter begin, Uint16ContainerConIter end, string& res) {$/;"	f	namespace:limonp
Unlock	limonp/MutexLock.hpp	/^  void Unlock() {$/;"	f	class:limonp::MutexLock
Update	limonp/Md5.hpp	/^  void Update($/;"	f	class:limonp::MD5
Upper	limonp/StringUtil.hpp	/^inline string& Upper(string& str) {$/;"	f	namespace:limonp
UserWordWeightOption	DictTrie.hpp	/^  enum UserWordWeightOption {$/;"	g	class:cppjieba::DictTrie
Utf8ToUnicode	limonp/StringUtil.hpp	/^bool Utf8ToUnicode(const char * const str, size_t len, Uint16Container& vec) {$/;"	f	namespace:limonp
Utf8ToUnicode	limonp/StringUtil.hpp	/^bool Utf8ToUnicode(const string& str, Uint16Container& vec) {$/;"	f	namespace:limonp
Utf8ToUnicode32	limonp/StringUtil.hpp	/^bool Utf8ToUnicode32(const string& str, Uint32Container& vec) {$/;"	f	namespace:limonp
Viterbi	HMMSegment.hpp	/^  void Viterbi(RuneStrArray::const_iterator begin, $/;"	f	class:cppjieba::HMMSegment
Wait	limonp/Condition.hpp	/^  void Wait() {$/;"	f	class:limonp::Condition
WeightCompare	DictTrie.hpp	/^  static bool WeightCompare(const DictUnit& lhs, const DictUnit& rhs) {$/;"	f	class:cppjieba::DictTrie
Word	KeywordExtractor.hpp	/^  struct Word {$/;"	s	class:cppjieba::KeywordExtractor
Word	TextRankExtractor.hpp	/^    typedef struct _Word {string word;vector<size_t> offsets;double weight;}    Word; \/\/ struct Word$/;"	t	class:cppjieba::TextRankExtractor	typeref:struct:cppjieba::TextRankExtractor::_Word
Word	Unicode.hpp	/^  Word(const string& w, uint32_t o)$/;"	f	struct:cppjieba::Word
Word	Unicode.hpp	/^struct Word {$/;"	s	namespace:cppjieba
WordGraph	TextRankExtractor.hpp	/^      WordGraph(): d(0.85) {};$/;"	f	class:cppjieba::TextRankExtractor::WordGraph
WordGraph	TextRankExtractor.hpp	/^      WordGraph(double in_d): d(in_d) {};$/;"	f	class:cppjieba::TextRankExtractor::WordGraph
WordGraph	TextRankExtractor.hpp	/^    class WordGraph{$/;"	c	class:cppjieba::TextRankExtractor
WordMap	TextRankExtractor.hpp	/^    typedef std::map<string,Word> WordMap;$/;"	t	class:cppjieba::TextRankExtractor
WordRange	Unicode.hpp	/^  WordRange(RuneStrArray::const_iterator l, RuneStrArray::const_iterator r)$/;"	f	struct:cppjieba::WordRange
WordRange	Unicode.hpp	/^struct WordRange {$/;"	s	namespace:cppjieba
WordWeightMax	DictTrie.hpp	/^    WordWeightMax,$/;"	e	enum:cppjieba::DictTrie::UserWordWeightOption
WordWeightMedian	DictTrie.hpp	/^    WordWeightMedian,$/;"	e	enum:cppjieba::DictTrie::UserWordWeightOption
WordWeightMin	DictTrie.hpp	/^    WordWeightMin,$/;"	e	enum:cppjieba::DictTrie::UserWordWeightOption
Worker	limonp/Thread.hpp	/^  static void * Worker(void * data) {$/;"	f	class:limonp::IThread
Worker	limonp/ThreadPool.hpp	/^    Worker(ThreadPool* pool): ptThreadPool_(pool) {$/;"	f	class:limonp::ThreadPool::Worker
Worker	limonp/ThreadPool.hpp	/^  class Worker: public IThread {$/;"	c	class:limonp::ThreadPool
XCHECK	limonp/Logging.hpp	/^#define XCHECK(/;"	d
XLOG	limonp/Logging.hpp	/^#define XLOG(/;"	d
YELLOW	limonp/Colors.hpp	/^  YELLOW,$/;"	e	enum:limonp::Color
_Word	TextRankExtractor.hpp	/^    typedef struct _Word {string word;vector<size_t> offsets;double weight;}    Word; \/\/ struct Word$/;"	s	class:cppjieba::TextRankExtractor
__MD5_H__	limonp/Md5.hpp	/^#define __MD5_H__$/;"	d
__context_t	limonp/Md5.hpp	/^  struct __context_t {$/;"	s	class:limonp::MD5
active_node_infos_	DictTrie.hpp	/^  deque<DictUnit> active_node_infos_; \/\/ must not be vector$/;"	m	class:cppjieba::DictTrie
addEdge	TextRankExtractor.hpp	/^      void addEdge(Node start,Node end,double weight){$/;"	f	class:cppjieba::TextRankExtractor::WordGraph
arg1_	limonp/Closure.hpp	/^  Arg1 arg1_;$/;"	m	class:limonp::Closure1
arg1_	limonp/Closure.hpp	/^  Arg1 arg1_;$/;"	m	class:limonp::Closure2
arg1_	limonp/Closure.hpp	/^  Arg1 arg1_;$/;"	m	class:limonp::Closure3
arg1_	limonp/Closure.hpp	/^  Arg1 arg1_;$/;"	m	class:limonp::ObjClosure1
arg1_	limonp/Closure.hpp	/^  Arg1 arg1_;$/;"	m	class:limonp::ObjClosure2
arg1_	limonp/Closure.hpp	/^  Arg1 arg1_;$/;"	m	class:limonp::ObjClosure3
arg2_	limonp/Closure.hpp	/^  Arg2 arg2_;$/;"	m	class:limonp::Closure2
arg2_	limonp/Closure.hpp	/^  Arg2 arg2_;$/;"	m	class:limonp::Closure3
arg2_	limonp/Closure.hpp	/^  Arg2 arg2_;$/;"	m	class:limonp::ObjClosure2
arg2_	limonp/Closure.hpp	/^  Arg2 arg2_;$/;"	m	class:limonp::ObjClosure3
arg3_	limonp/Closure.hpp	/^  Arg3 arg3_;$/;"	m	class:limonp::Closure3
arg3_	limonp/Closure.hpp	/^  Arg3 arg3_;$/;"	m	class:limonp::ObjClosure3
args_	limonp/ArgvContext.hpp	/^  vector<string> args_;$/;"	m	class:limonp::ArgvContext
begin	Jieba.hpp	/^    size_t begin;$/;"	m	struct:cppjieba::Jieba::LocWord
begin	PreFilter.hpp	/^    RuneStrArray::const_iterator begin;$/;"	m	struct:cppjieba::PreFilter::Range
begin	limonp/LocalVector.hpp	/^  const_iterator begin() const {$/;"	f	class:limonp::LocalVector
buffer	limonp/Md5.hpp	/^    unsigned char buffer[64];                         \/* input buffer *\/$/;"	m	struct:limonp::MD5::__context_t
buffer_	limonp/LocalVector.hpp	/^  T buffer_[LOCAL_VECTOR_BUFFER_SIZE];$/;"	m	class:limonp::LocalVector
capacity	limonp/BoundedBlockingQueue.hpp	/^  size_t capacity() const {$/;"	f	class:limonp::BoundedBlockingQueue
capacity	limonp/LocalVector.hpp	/^  size_t capacity() const {$/;"	f	class:limonp::LocalVector
capacity_	limonp/BoundedQueue.hpp	/^  const size_t capacity_;$/;"	m	class:limonp::BoundedQueue
capacity_	limonp/LocalVector.hpp	/^  size_t capacity_;$/;"	m	class:limonp::LocalVector
circular_buffer_	limonp/BoundedQueue.hpp	/^  vector<T> circular_buffer_;$/;"	m	class:limonp::BoundedQueue
clear	limonp/LocalVector.hpp	/^  void clear() {$/;"	f	class:limonp::LocalVector
const_iterator	limonp/LocalVector.hpp	/^  typedef const T* const_iterator ;$/;"	t	class:limonp::LocalVector
context	limonp/Md5.hpp	/^  } context ;$/;"	m	class:limonp::MD5	typeref:struct:limonp::MD5::__context_t
count	limonp/Md5.hpp	/^    UINT4 count[2];        \/* number of bits, modulo 2^64 (lsb first) *\/$/;"	m	struct:limonp::MD5::__context_t
cppjieba	DictTrie.hpp	/^namespace cppjieba {$/;"	n
cppjieba	FullSegment.hpp	/^namespace cppjieba {$/;"	n
cppjieba	HMMModel.hpp	/^namespace cppjieba {$/;"	n
cppjieba	HMMSegment.hpp	/^namespace cppjieba {$/;"	n
cppjieba	Jieba.hpp	/^namespace cppjieba {$/;"	n
cppjieba	KeywordExtractor.hpp	/^namespace cppjieba {$/;"	n
cppjieba	MPSegment.hpp	/^namespace cppjieba {$/;"	n
cppjieba	MixSegment.hpp	/^namespace cppjieba {$/;"	n
cppjieba	PosTagger.hpp	/^namespace cppjieba {$/;"	n
cppjieba	PreFilter.hpp	/^namespace cppjieba {$/;"	n
cppjieba	QuerySegment.hpp	/^namespace cppjieba {$/;"	n
cppjieba	SegmentBase.hpp	/^namespace cppjieba {$/;"	n
cppjieba	SegmentTagged.hpp	/^namespace cppjieba {$/;"	n
cppjieba	TextRankExtractor.hpp	/^namespace cppjieba {$/;"	n
cppjieba	Trie.hpp	/^namespace cppjieba {$/;"	n
cppjieba	Unicode.hpp	/^namespace cppjieba {$/;"	n
cursor_	PreFilter.hpp	/^  RuneStrArray::const_iterator cursor_;$/;"	m	class:cppjieba::PreFilter
d	TextRankExtractor.hpp	/^      double d;$/;"	m	class:cppjieba::TextRankExtractor::WordGraph
dictTrie_	FullSegment.hpp	/^  const DictTrie* dictTrie_;$/;"	m	class:cppjieba::FullSegment
dictTrie_	MPSegment.hpp	/^  const DictTrie* dictTrie_;$/;"	m	class:cppjieba::MPSegment
dict_trie_	Jieba.hpp	/^  DictTrie dict_trie_;$/;"	m	class:cppjieba::Jieba
digestChars	limonp/Md5.hpp	/^  char digestChars[ 33 ] ;$/;"	m	class:limonp::MD5
digestFile	limonp/Md5.hpp	/^  const char* digestFile( const char *filename ) {$/;"	f	class:limonp::MD5
digestMemory	limonp/Md5.hpp	/^  const char* digestMemory( BYTE *memchunk, int len ) {$/;"	f	class:limonp::MD5
digestRaw	limonp/Md5.hpp	/^  BYTE digestRaw[ 16 ] ;$/;"	m	class:limonp::MD5
digestString	limonp/Md5.hpp	/^  const char* digestString(const char *string ) {$/;"	f	class:limonp::MD5
emitProbB	HMMModel.hpp	/^  EmitProbMap emitProbB;$/;"	m	struct:cppjieba::HMMModel
emitProbE	HMMModel.hpp	/^  EmitProbMap emitProbE;$/;"	m	struct:cppjieba::HMMModel
emitProbM	HMMModel.hpp	/^  EmitProbMap emitProbM;$/;"	m	struct:cppjieba::HMMModel
emitProbS	HMMModel.hpp	/^  EmitProbMap emitProbS;$/;"	m	struct:cppjieba::HMMModel
emitProbVec	HMMModel.hpp	/^  vector<EmitProbMap* > emitProbVec;$/;"	m	struct:cppjieba::HMMModel
empty	limonp/LocalVector.hpp	/^  bool empty() const {$/;"	f	class:limonp::LocalVector
end	Jieba.hpp	/^    size_t end;$/;"	m	struct:cppjieba::Jieba::LocWord
end	PreFilter.hpp	/^    RuneStrArray::const_iterator end;$/;"	m	struct:cppjieba::PreFilter::Range
end	limonp/LocalVector.hpp	/^  const_iterator end() const {$/;"	f	class:limonp::LocalVector
err_	limonp/FileLock.hpp	/^  string err_;$/;"	m	class:limonp::FileLock
fd_	limonp/FileLock.hpp	/^  int fd_;$/;"	m	class:limonp::FileLock
freq_sum_	DictTrie.hpp	/^  double freq_sum_;$/;"	m	class:cppjieba::DictTrie
full_seg_	Jieba.hpp	/^  FullSegment full_seg_;$/;"	m	class:cppjieba::Jieba
fun_	limonp/Closure.hpp	/^  Funct fun_;$/;"	m	class:limonp::Closure0
fun_	limonp/Closure.hpp	/^  Funct fun_;$/;"	m	class:limonp::Closure1
fun_	limonp/Closure.hpp	/^  Funct fun_;$/;"	m	class:limonp::Closure2
fun_	limonp/Closure.hpp	/^  Funct fun_;$/;"	m	class:limonp::Closure3
fun_	limonp/Closure.hpp	/^  Funct fun_;$/;"	m	class:limonp::ObjClosure0
fun_	limonp/Closure.hpp	/^  Funct fun_;$/;"	m	class:limonp::ObjClosure1
fun_	limonp/Closure.hpp	/^  Funct fun_;$/;"	m	class:limonp::ObjClosure2
fun_	limonp/Closure.hpp	/^  Funct fun_;$/;"	m	class:limonp::ObjClosure3
graph	TextRankExtractor.hpp	/^      Graph graph;$/;"	m	class:cppjieba::TextRankExtractor::WordGraph
head_	limonp/BoundedQueue.hpp	/^  size_t head_;$/;"	m	class:limonp::BoundedQueue
hmmSeg_	MixSegment.hpp	/^  HMMSegment hmmSeg_;$/;"	m	class:cppjieba::MixSegment
hmm_seg_	Jieba.hpp	/^  HMMSegment hmm_seg_;$/;"	m	class:cppjieba::Jieba
idfAverage_	KeywordExtractor.hpp	/^  double idfAverage_;$/;"	m	class:cppjieba::KeywordExtractor
idfMap_	KeywordExtractor.hpp	/^  unordered_map<string, double> idfMap_;$/;"	m	class:cppjieba::KeywordExtractor
init_	limonp/LocalVector.hpp	/^  void init_() {$/;"	f	class:limonp::LocalVector
isJoined	limonp/Thread.hpp	/^  bool isJoined;$/;"	m	class:limonp::IThread
isNeedDestroy_	FullSegment.hpp	/^  bool isNeedDestroy_;$/;"	m	class:cppjieba::FullSegment
isNeedDestroy_	HMMSegment.hpp	/^  bool isNeedDestroy_;$/;"	m	class:cppjieba::HMMSegment
isNeedDestroy_	MPSegment.hpp	/^  bool isNeedDestroy_;$/;"	m	class:cppjieba::MPSegment
isStarted	limonp/Thread.hpp	/^  bool isStarted;$/;"	m	class:limonp::IThread
left	Unicode.hpp	/^  RuneStrArray::const_iterator left;$/;"	m	struct:cppjieba::WordRange
len	Unicode.hpp	/^  uint32_t len;$/;"	m	struct:cppjieba::RuneStr
len	Unicode.hpp	/^  uint32_t len;$/;"	m	struct:cppjieba::RuneStrLite
level_	limonp/Logging.hpp	/^  size_t level_;$/;"	m	class:limonp::Logger
limonp	limonp/ArgvContext.hpp	/^namespace limonp {$/;"	n
limonp	limonp/BlockingQueue.hpp	/^namespace limonp {$/;"	n
limonp	limonp/BoundedBlockingQueue.hpp	/^namespace limonp {$/;"	n
limonp	limonp/BoundedQueue.hpp	/^namespace limonp {$/;"	n
limonp	limonp/Closure.hpp	/^namespace limonp {$/;"	n
limonp	limonp/Colors.hpp	/^namespace limonp {$/;"	n
limonp	limonp/Condition.hpp	/^namespace limonp {$/;"	n
limonp	limonp/Config.hpp	/^namespace limonp {$/;"	n
limonp	limonp/FileLock.hpp	/^namespace limonp {$/;"	n
limonp	limonp/LocalVector.hpp	/^namespace limonp {$/;"	n
limonp	limonp/Logging.hpp	/^namespace limonp {$/;"	n
limonp	limonp/Md5.hpp	/^namespace limonp {$/;"	n
limonp	limonp/MutexLock.hpp	/^namespace limonp {$/;"	n
limonp	limonp/NonCopyable.hpp	/^namespace limonp {$/;"	n
limonp	limonp/StringUtil.hpp	/^namespace limonp {$/;"	n
limonp	limonp/Thread.hpp	/^namespace limonp {$/;"	n
limonp	limonp/ThreadPool.hpp	/^namespace limonp {$/;"	n
map_	limonp/Config.hpp	/^  map<string, string> map_;$/;"	m	class:limonp::Config
max_weight_	DictTrie.hpp	/^  double max_weight_;$/;"	m	class:cppjieba::DictTrie
md5File	limonp/Md5.hpp	/^inline bool md5File(const char* filepath, std::string& res) {$/;"	f	namespace:limonp
md5String	limonp/Md5.hpp	/^inline bool md5String(const char* str, std::string& res) {$/;"	f	namespace:limonp
median_weight_	DictTrie.hpp	/^  double median_weight_;$/;"	m	class:cppjieba::DictTrie
min_weight_	DictTrie.hpp	/^  double min_weight_;$/;"	m	class:cppjieba::DictTrie
mixSeg_	QuerySegment.hpp	/^  MixSegment mixSeg_;$/;"	m	class:cppjieba::QuerySegment
mix_seg_	Jieba.hpp	/^  MixSegment mix_seg_;$/;"	m	class:cppjieba::Jieba
model_	HMMSegment.hpp	/^  const HMMModel* model_;$/;"	m	class:cppjieba::HMMSegment
model_	Jieba.hpp	/^  HMMModel model_;$/;"	m	class:cppjieba::Jieba
mpSeg_	MixSegment.hpp	/^  MPSegment mpSeg_;$/;"	m	class:cppjieba::MixSegment
mp_seg_	Jieba.hpp	/^  MPSegment mp_seg_;$/;"	m	class:cppjieba::Jieba
mpss_	limonp/ArgvContext.hpp	/^  map<string, string> mpss_;$/;"	m	class:limonp::ArgvContext
mutex_	limonp/BlockingQueue.hpp	/^  mutable MutexLock mutex_;$/;"	m	class:limonp::BlockingQueue
mutex_	limonp/BoundedBlockingQueue.hpp	/^  mutable MutexLock          mutex_;$/;"	m	class:limonp::BoundedBlockingQueue
mutex_	limonp/Condition.hpp	/^  MutexLock& mutex_;$/;"	m	class:limonp::Condition
mutex_	limonp/MutexLock.hpp	/^  MutexLock & mutex_;$/;"	m	class:limonp::MutexLockGuard
mutex_	limonp/MutexLock.hpp	/^  pthread_mutex_t mutex_;$/;"	m	class:limonp::MutexLock
next	Trie.hpp	/^  NextMap *next;$/;"	m	class:cppjieba::TrieNode
nextPos	Trie.hpp	/^  size_t nextPos; \/\/ TODO$/;"	m	struct:cppjieba::Dag
nexts	Trie.hpp	/^  limonp::LocalVector<pair<size_t, const DictUnit*> > nexts;$/;"	m	struct:cppjieba::Dag
nodeSet	TextRankExtractor.hpp	/^      NodeSet nodeSet;$/;"	m	class:cppjieba::TextRankExtractor::WordGraph
notEmpty_	limonp/BlockingQueue.hpp	/^  Condition         notEmpty_;$/;"	m	class:limonp::BlockingQueue
notEmpty_	limonp/BoundedBlockingQueue.hpp	/^  Condition                  notEmpty_;$/;"	m	class:limonp::BoundedBlockingQueue
notFull_	limonp/BoundedBlockingQueue.hpp	/^  Condition                  notFull_;$/;"	m	class:limonp::BoundedBlockingQueue
offset	Unicode.hpp	/^  uint32_t offset;$/;"	m	struct:cppjieba::RuneStr
offset	Unicode.hpp	/^  uint32_t offset;$/;"	m	struct:cppjieba::Word
offsets	KeywordExtractor.hpp	/^    vector<size_t> offsets;$/;"	m	struct:cppjieba::KeywordExtractor::Word
offsets	TextRankExtractor.hpp	/^    typedef struct _Word {string word;vector<size_t> offsets;double weight;}    Word; \/\/ struct Word$/;"	m	struct:cppjieba::TextRankExtractor::_Word
ok_	limonp/FileLock.hpp	/^  bool ok_;$/;"	m	class:limonp::FileLock
operator <<	KeywordExtractor.hpp	/^inline ostream& operator << (ostream& os, const KeywordExtractor::Word& word) {$/;"	f	namespace:cppjieba
operator <<	TextRankExtractor.hpp	/^  inline ostream& operator << (ostream& os, const TextRankExtractor::Word& word) {$/;"	f	namespace:cppjieba
operator <<	Unicode.hpp	/^inline std::ostream& operator << (std::ostream& os, const RuneStr& r) {$/;"	f	namespace:cppjieba
operator <<	Unicode.hpp	/^inline std::ostream& operator << (std::ostream& os, const Word& w) {$/;"	f	namespace:cppjieba
operator <<	limonp/ArgvContext.hpp	/^inline ostream& operator << (ostream& os, const ArgvContext& args) {$/;"	f	namespace:limonp
operator <<	limonp/Config.hpp	/^inline ostream& operator << (ostream& os, const Config& config) {$/;"	f	namespace:limonp
operator <<	limonp/LocalVector.hpp	/^ostream & operator << (ostream& os, const LocalVector<T>& vec) {$/;"	f	namespace:limonp
operator <<	limonp/StdExtension.hpp	/^basic_string<T> & operator << (basic_string<T> & s, ifstream & ifs) {$/;"	f	namespace:std
operator <<	limonp/StdExtension.hpp	/^inline ostream& operator << (ostream& os, const vector<string>& v) {$/;"	f	namespace:std
operator <<	limonp/StdExtension.hpp	/^ofstream & operator << (ofstream & ofs, const basic_string<T>& s) {$/;"	f	namespace:std
operator <<	limonp/StdExtension.hpp	/^ostream& operator << (ostream& os, const deque<T>& dq) {$/;"	f	namespace:std
operator <<	limonp/StdExtension.hpp	/^ostream& operator << (ostream& os, const map<T1, T2>& mp) {$/;"	f	namespace:std
operator <<	limonp/StdExtension.hpp	/^ostream& operator << (ostream& os, const pair<T1, T2>& pr) {$/;"	f	namespace:std
operator <<	limonp/StdExtension.hpp	/^ostream& operator << (ostream& os, const set<T>& st) {$/;"	f	namespace:std
operator <<	limonp/StdExtension.hpp	/^ostream& operator << (ostream& os, const std::unordered_map<T1, T2>& mp) {$/;"	f	namespace:std
operator <<	limonp/StdExtension.hpp	/^ostream& operator << (ostream& os, const vector<T>& v) {$/;"	f	namespace:std
operator <<	limonp/StdExtension.hpp	/^string& operator << (string& str, const T& obj) {$/;"	f	namespace:std
operator =	limonp/LocalVector.hpp	/^  LocalVector<T>& operator = (const LocalVector<T>& vec) {$/;"	f	class:limonp::LocalVector
operator []	limonp/ArgvContext.hpp	/^  string operator [](const string& key) const {$/;"	f	class:limonp::ArgvContext
operator []	limonp/ArgvContext.hpp	/^  string operator [](size_t i) const {$/;"	f	class:limonp::ArgvContext
operator []	limonp/Config.hpp	/^  const char* operator [] (const char* key) const {$/;"	f	class:limonp::Config
operator []	limonp/LocalVector.hpp	/^  T& operator [] (size_t i) {$/;"	f	class:limonp::LocalVector
operator []	limonp/LocalVector.hpp	/^  const T& operator [] (size_t i) const {$/;"	f	class:limonp::LocalVector
operator bool	limonp/Config.hpp	/^  operator bool () {$/;"	f	class:limonp::Config
pInfo	Trie.hpp	/^  const DictUnit * pInfo;$/;"	m	struct:cppjieba::Dag
p_	limonp/Closure.hpp	/^  Obj* p_;$/;"	m	class:limonp::ObjClosure0
p_	limonp/Closure.hpp	/^  Obj* p_;$/;"	m	class:limonp::ObjClosure1
p_	limonp/Closure.hpp	/^  Obj* p_;$/;"	m	class:limonp::ObjClosure2
p_	limonp/Closure.hpp	/^  Obj* p_;$/;"	m	class:limonp::ObjClosure3
pcond_	limonp/Condition.hpp	/^  pthread_cond_t pcond_;$/;"	m	class:limonp::Condition
print	limonp/StdExtension.hpp	/^#define print(/;"	d
private	limonp/ForcePublic.hpp	/^#define private /;"	d
protected	limonp/ForcePublic.hpp	/^#define protected /;"	d
ptThreadPool_	limonp/ThreadPool.hpp	/^    ThreadPool * ptThreadPool_;$/;"	m	class:limonp::ThreadPool::Worker
ptValue	Trie.hpp	/^  const DictUnit *ptValue;$/;"	m	class:cppjieba::TrieNode
ptr_	limonp/LocalVector.hpp	/^  T * ptr_;$/;"	m	class:limonp::LocalVector
push_back	limonp/LocalVector.hpp	/^  void push_back(const T& t) {$/;"	f	class:limonp::LocalVector
query_seg_	Jieba.hpp	/^  QuerySegment query_seg_;$/;"	m	class:cppjieba::Jieba
queue_	limonp/BlockingQueue.hpp	/^  std::queue<T>     queue_;$/;"	m	class:limonp::BlockingQueue
queue_	limonp/BoundedBlockingQueue.hpp	/^  BoundedQueue<T>  queue_;$/;"	m	class:limonp::BoundedBlockingQueue
queue_	limonp/ThreadPool.hpp	/^  BoundedBlockingQueue<ClosureInterface*> queue_;$/;"	m	class:limonp::ThreadPool
rank	TextRankExtractor.hpp	/^      void rank(WordMap &ws,size_t rankTime=10){$/;"	f	class:cppjieba::TextRankExtractor::WordGraph
reserve	limonp/LocalVector.hpp	/^  void reserve(size_t size) {$/;"	f	class:limonp::LocalVector
right	Unicode.hpp	/^  RuneStrArray::const_iterator right;$/;"	m	struct:cppjieba::WordRange
root_	Trie.hpp	/^  TrieNode* root_;$/;"	m	class:cppjieba::Trie
rune	Unicode.hpp	/^  Rune rune;$/;"	m	struct:cppjieba::RuneStr
rune	Unicode.hpp	/^  uint32_t rune;$/;"	m	struct:cppjieba::RuneStrLite
runestr	Trie.hpp	/^  RuneStr runestr;$/;"	m	struct:cppjieba::Dag
segment_	KeywordExtractor.hpp	/^  MixSegment segment_;$/;"	m	class:cppjieba::KeywordExtractor
segment_	TextRankExtractor.hpp	/^    MixSegment segment_;$/;"	m	class:cppjieba::TextRankExtractor
sentence_	PreFilter.hpp	/^  RuneStrArray sentence_;$/;"	m	class:cppjieba::PreFilter
size	limonp/BoundedBlockingQueue.hpp	/^  size_t size() const {$/;"	f	class:limonp::BoundedBlockingQueue
size	limonp/LocalVector.hpp	/^  size_t size() const {$/;"	f	class:limonp::LocalVector
size_	limonp/BoundedQueue.hpp	/^  size_t size_;$/;"	m	class:limonp::BoundedQueue
size_	limonp/LocalVector.hpp	/^  size_t size_;$/;"	m	class:limonp::LocalVector
size_type	limonp/LocalVector.hpp	/^  typedef size_t size_type;$/;"	t	class:limonp::LocalVector
sset_	limonp/ArgvContext.hpp	/^  set<string> sset_;$/;"	m	class:limonp::ArgvContext
startProb	HMMModel.hpp	/^  double startProb[STATUS_SUM];$/;"	m	struct:cppjieba::HMMModel
statMap	HMMModel.hpp	/^  char statMap[STATUS_SUM];$/;"	m	struct:cppjieba::HMMModel
state	limonp/Md5.hpp	/^    UINT4 state[4];                                   \/* state (ABCD) *\/$/;"	m	struct:limonp::MD5::__context_t
static_node_infos_	DictTrie.hpp	/^  vector<DictUnit> static_node_infos_;$/;"	m	class:cppjieba::DictTrie
std	limonp/StdExtension.hpp	/^namespace std {$/;"	n
stopWords_	KeywordExtractor.hpp	/^  unordered_set<string> stopWords_;$/;"	m	class:cppjieba::KeywordExtractor
stopWords_	TextRankExtractor.hpp	/^    unordered_set<string> stopWords_;$/;"	m	class:cppjieba::TextRankExtractor
stream_	limonp/Logging.hpp	/^  std::ostringstream stream_;$/;"	m	class:limonp::Logger
symbols_	PreFilter.hpp	/^  const unordered_set<Rune>& symbols_;$/;"	m	class:cppjieba::PreFilter
symbols_	SegmentBase.hpp	/^  unordered_set<Rune> symbols_;$/;"	m	class:cppjieba::SegmentBase
tag	Trie.hpp	/^  string tag;$/;"	m	struct:cppjieba::DictUnit
tagger_	MPSegment.hpp	/^  PosTagger tagger_;$/;"	m	class:cppjieba::MPSegment
tagger_	MixSegment.hpp	/^  PosTagger tagger_;$/;"	m	class:cppjieba::MixSegment
tail_	limonp/BoundedQueue.hpp	/^  size_t tail_;$/;"	m	class:limonp::BoundedQueue
thread_	limonp/Thread.hpp	/^  pthread_t thread_;$/;"	m	class:limonp::IThread
threads_	limonp/ThreadPool.hpp	/^  vector<IThread*> threads_;$/;"	m	class:limonp::ThreadPool
transProb	HMMModel.hpp	/^  double transProb[STATUS_SUM][STATUS_SUM];$/;"	m	struct:cppjieba::HMMModel
trie_	DictTrie.hpp	/^  Trie * trie_;$/;"	m	class:cppjieba::DictTrie
trie_	QuerySegment.hpp	/^  const DictTrie* trie_;$/;"	m	class:cppjieba::QuerySegment
user_dict_single_chinese_word_	DictTrie.hpp	/^  unordered_set<Rune> user_dict_single_chinese_word_;$/;"	m	class:cppjieba::DictTrie
user_word_default_weight_	DictTrie.hpp	/^  double user_word_default_weight_;$/;"	m	class:cppjieba::DictTrie
value_type	limonp/LocalVector.hpp	/^  typedef T value_type;$/;"	t	class:limonp::LocalVector
weight	KeywordExtractor.hpp	/^    double weight;$/;"	m	struct:cppjieba::KeywordExtractor::Word
weight	TextRankExtractor.hpp	/^    typedef struct _Word {string word;vector<size_t> offsets;double weight;}    Word; \/\/ struct Word$/;"	m	struct:cppjieba::TextRankExtractor::_Word
weight	Trie.hpp	/^  double weight;$/;"	m	struct:cppjieba::Dag
weight	Trie.hpp	/^  double weight;$/;"	m	struct:cppjieba::DictUnit
word	Jieba.hpp	/^    string word;$/;"	m	struct:cppjieba::Jieba::LocWord
word	KeywordExtractor.hpp	/^    string word;$/;"	m	struct:cppjieba::KeywordExtractor::Word
word	TextRankExtractor.hpp	/^    typedef struct _Word {string word;vector<size_t> offsets;double weight;}    Word; \/\/ struct Word$/;"	m	struct:cppjieba::TextRankExtractor::_Word
word	Trie.hpp	/^  Unicode word;$/;"	m	struct:cppjieba::DictUnit
word	Unicode.hpp	/^  string word;$/;"	m	struct:cppjieba::Word
writeToString	limonp/Md5.hpp	/^  void writeToString() {$/;"	f	class:limonp::MD5
~ArgvContext	limonp/ArgvContext.hpp	/^  ~ArgvContext() {$/;"	f	class:limonp::ArgvContext
~BoundedQueue	limonp/BoundedQueue.hpp	/^  ~BoundedQueue() {$/;"	f	class:limonp::BoundedQueue
~Closure0	limonp/Closure.hpp	/^  virtual ~Closure0() {$/;"	f	class:limonp::Closure0
~Closure1	limonp/Closure.hpp	/^  virtual ~Closure1() {$/;"	f	class:limonp::Closure1
~Closure2	limonp/Closure.hpp	/^  virtual ~Closure2() {$/;"	f	class:limonp::Closure2
~Closure3	limonp/Closure.hpp	/^  virtual ~Closure3() {$/;"	f	class:limonp::Closure3
~ClosureInterface	limonp/Closure.hpp	/^  virtual ~ClosureInterface() {$/;"	f	class:limonp::ClosureInterface
~Condition	limonp/Condition.hpp	/^  ~Condition() {$/;"	f	class:limonp::Condition
~DictTrie	DictTrie.hpp	/^  ~DictTrie() {$/;"	f	class:cppjieba::DictTrie
~FileLock	limonp/FileLock.hpp	/^  ~FileLock() {$/;"	f	class:limonp::FileLock
~FullSegment	FullSegment.hpp	/^  ~FullSegment() {$/;"	f	class:cppjieba::FullSegment
~HMMModel	HMMModel.hpp	/^  ~HMMModel() {$/;"	f	struct:cppjieba::HMMModel
~HMMSegment	HMMSegment.hpp	/^  ~HMMSegment() {$/;"	f	class:cppjieba::HMMSegment
~IThread	limonp/Thread.hpp	/^  virtual ~IThread() {$/;"	f	class:limonp::IThread
~Jieba	Jieba.hpp	/^  ~Jieba() {$/;"	f	class:cppjieba::Jieba
~KeywordExtractor	KeywordExtractor.hpp	/^  ~KeywordExtractor() {$/;"	f	class:cppjieba::KeywordExtractor
~LocalVector	limonp/LocalVector.hpp	/^  ~LocalVector() {$/;"	f	class:limonp::LocalVector
~Logger	limonp/Logging.hpp	/^  ~Logger() {$/;"	f	class:limonp::Logger
~MPSegment	MPSegment.hpp	/^  ~MPSegment() {$/;"	f	class:cppjieba::MPSegment
~MixSegment	MixSegment.hpp	/^  ~MixSegment() {$/;"	f	class:cppjieba::MixSegment
~MutexLock	limonp/MutexLock.hpp	/^  ~MutexLock() {$/;"	f	class:limonp::MutexLock
~MutexLockGuard	limonp/MutexLock.hpp	/^  ~MutexLockGuard() {$/;"	f	class:limonp::MutexLockGuard
~NonCopyable	limonp/NonCopyable.hpp	/^  ~NonCopyable() {$/;"	f	class:limonp::NonCopyable
~ObjClosure0	limonp/Closure.hpp	/^  virtual ~ObjClosure0() {$/;"	f	class:limonp::ObjClosure0
~ObjClosure1	limonp/Closure.hpp	/^  virtual ~ObjClosure1() {$/;"	f	class:limonp::ObjClosure1
~ObjClosure2	limonp/Closure.hpp	/^  virtual ~ObjClosure2() {$/;"	f	class:limonp::ObjClosure2
~ObjClosure3	limonp/Closure.hpp	/^  virtual ~ObjClosure3() {$/;"	f	class:limonp::ObjClosure3
~PosTagger	PosTagger.hpp	/^  ~PosTagger() {$/;"	f	class:cppjieba::PosTagger
~PreFilter	PreFilter.hpp	/^  ~PreFilter() {$/;"	f	class:cppjieba::PreFilter
~QuerySegment	QuerySegment.hpp	/^  ~QuerySegment() {$/;"	f	class:cppjieba::QuerySegment
~SegmentBase	SegmentBase.hpp	/^  virtual ~SegmentBase() {$/;"	f	class:cppjieba::SegmentBase
~SegmentTagged	SegmentTagged.hpp	/^  virtual ~SegmentTagged() {$/;"	f	class:cppjieba::SegmentTagged
~TextRankExtractor	TextRankExtractor.hpp	/^    ~TextRankExtractor() {$/;"	f	class:cppjieba::TextRankExtractor
~ThreadPool	limonp/ThreadPool.hpp	/^  ~ThreadPool() {$/;"	f	class:limonp::ThreadPool
~Trie	Trie.hpp	/^  ~Trie() {$/;"	f	class:cppjieba::Trie
~Worker	limonp/ThreadPool.hpp	/^    virtual ~Worker() {$/;"	f	class:limonp::ThreadPool::Worker
